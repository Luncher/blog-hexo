---
title: 一款在线秒杀游戏的设计
date: 2018-11-01 19:02:20
tags:
categories: server
---


秒杀的场景常见于在线商户，12306抢火车票等等。它们的特点都是类似，即：在某一个瞬间并发大量请求。而这个请求量如果不加以防范很可能会超过系统的负载能力，使得系统崩溃，影响公司的其他正常业务。

<!-- more -->

最近公司在做一个游戏项目，游戏的玩法类似于秒杀活动：
>"用户投入金币购买算力帮助AI获得算力，构建美丽新世界。游戏时间是有限的，在某个点投入金币获得额外的奖励。"

### 预估请求量

秒杀活动顾名思义：物品数量有限，而用户数量庞大。首先要做的是预估请求数量，也就是说：预计有多少个用户能真正获得商品。举个例子：某在线商城要进行一个1元秒杀手机的活动，数量200台，每个用户限一台。那么实际成功的最大请求数量也就是200，其余的请求发送到服务器可以统一返回售罄的错误信息。对于这类需求，瓶颈通常在数据库层面。这个时候需要加一个缓存队列。每次用户发送购买请求，先判定缓存的长度，如果小于预估的请求数量则把购买请求入队列：

![server-game1](/images/server-game.png)


### 处理正常请求

通过前面一个缓存队列，已经把绝大多数请求抵挡住了。现在要开始处理正常的购买请求。正常请求的处理逻辑基于解耦考虑通常放置在不同的模块。通过一个消息队列来通信。

![server-game2](/images/server-game2.png)


### 查询购买状态

由于用户的请求量比较大，而用户往往会不断的刷新页面，查询是否已经抢购到了商品，所以最好通过缓存队列来查询购买的状态，如果购买记录不在队列中，默认已经售罄。

![server-game3](/images/server-game3.png)


### 注意事项：

用户请求入缓存队列之后，会给处理购买的模块发送一条消息。在消息队列的选型要看清是`at least once`还是`at most one`或者`exact once`。通常队列实现的都是`at least once`。这个时候要做到处理逻辑必须是可重入的。